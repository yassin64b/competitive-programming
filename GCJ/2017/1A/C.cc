/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>

using namespace std;

struct state {
    int Hd, Ad, Hk, Ak;
};
bool operator<(const state& lhs, const state& rhs) {
    return lhs.Hd < rhs.Hd || (lhs.Hd == rhs.Hd && lhs.Ad < rhs.Ad)
            || (lhs.Hd == rhs.Hd && lhs.Ad == rhs.Ad && lhs.Hk < rhs.Hk)
           || (lhs.Hd == rhs.Hd && lhs.Ad == rhs.Ad && lhs.Hk == rhs.Hk && lhs.Ak < rhs.Ak);
}
constexpr int INF = 1000 * 1000 * 1000;

class TaskC {
public:
    void solve(istream& in, ostream& out) {
        int T;
        in >> T;
        for (int t = 1; t <= T; ++t) {
            int Hd, Ad, Hk, Ak, B, D;
            in >> Hd >> Ad >> Hk >> Ak >> B >> D;
            int save_Hd = Hd;
            
            int turn = INF;
            queue<pair<state, int>> q;
            set<state> m;
            q.push({{Hd, Ad, Hk, Ak}, 0});
            //cout << "next " << endl;
            while (!q.empty()) {
                state cur = q.front().first;
                int cur_turn = q.front().second;
                //cout << cur.Hd << " " << cur.Ad << " " << cur.Hk << " " << cur.Ak << " " << cur_turn << endl;
                q.pop();
                if (cur_turn+1 >= turn) {
                    continue;
                }
                if (cur.Hk - cur.Ad <= 0) { //1
                    turn = min(turn, cur_turn + 1);
                    //cout << "won " << endl;
                } else if (cur.Hd - cur.Ak > 0
                           && m.find({cur.Hd - cur.Ak, cur.Ad, cur.Hk - cur.Ad, cur.Ak}) == m.end()) {
                    q.push({{cur.Hd - cur.Ak, cur.Ad, cur.Hk - cur.Ad, cur.Ak}, cur_turn+1});
                    m.insert({cur.Hd - cur.Ak, cur.Ad, cur.Hk - cur.Ad, cur.Ak});
                }
                if (cur.Hd - cur.Ak > 0
                    && m.find({cur.Hd - cur.Ak, cur.Ad + B, cur.Hk, cur.Ak}) == m.end()) { //2
                    q.push({{cur.Hd - cur.Ak, cur.Ad + B, cur.Hk, cur.Ak}, cur_turn+1});
                    m.insert({cur.Hd - cur.Ak, cur.Ad + B, cur.Hk, cur.Ak});
                }
                if (save_Hd - cur.Ak > 0
                    && m.find({save_Hd - cur.Ak, cur.Ad, cur.Hk, cur.Ak}) == m.end()) { //3
                    q.push({{save_Hd - cur.Ak, cur.Ad, cur.Hk, cur.Ak}, cur_turn+1});
                    m.insert({save_Hd - cur.Ak, cur.Ad, cur.Hk, cur.Ak});
                }
                int tmp = max(cur.Ak - D, 0);
                if (D > 0 && cur.Hd - tmp > 0
                    && m.find({cur.Hd - tmp, cur.Ad, cur.Hk, tmp}) == m.end()) { //3
                    q.push({{cur.Hd - tmp, cur.Ad, cur.Hk, tmp}, cur_turn+1});
                    m.insert({cur.Hd - tmp, cur.Ad, cur.Hk, tmp});
                }
            }
            
            out << "Case #" << t << ": ";
            if (turn == INF) {
                out << "IMPOSSIBLE\n";
            } else {
                out << turn << "\n";
            }
        }
    }
};

int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    TaskC solver;
    std::istream& in(cin);
    std::ostream& out(cout);
    solver.solve(in, out);
    return 0;
}
