/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>
#include <sstream>
#include <unordered_map>
using namespace std;

using int64 = long long;


class vec_hash {
public:
    std::size_t operator()(tuple<int64, int64, int64> const& t) const {
        std::size_t seed = (get<0>(t));
        std::size_t seed1 = (get<1>(t));
        std::size_t seed2 = (get<2>(t));
        seed ^= 1 + 0x9e3779b9 + (seed1 << 6) + (seed1 >> 2);
        seed ^= 2 + 0x9e3779b9 + (seed2 << 6) + (seed2 >> 2);
        return seed;
    }
};

void add(tuple<int64, int64, int64>& a, const tuple<int64, int64, int64>& b) {
    get<0>(a) += get<0>(b);
    get<1>(a) += get<1>(b);
    get<2>(a) += get<2>(b);
    
}

class aoc20_1 {
public:
    void solve(istream& in, ostream& out) {
        vector<vector<tuple<int64, int64, int64>>> parts;
        string s;
        while (getline(in, s)) {
            stringstream ss(s);
            char c;
            long long x, y, z;
            vector<tuple<int64, int64, int64>> cur;
            ss >> c >> c >> c >> x >> c >> y >> c >> z >> c >> c;
            cur.emplace_back(x, y, z);
            ss >> c >> c >> c >> x >> c >> y >> c >> z >> c >> c;
            cur.emplace_back(x, y, z);
            ss >> c >> c >> c >> x >> c >> y >> c >> z >> c >> c;
            cur.emplace_back(x, y, z);
            parts.push_back(cur);
        }
        for (int k = 0; k < 10'000; ++k) {
            unordered_map<tuple<int64, int64, int64>, vector<int>, vec_hash> m;
            for (int i = 0; i < (int)parts.size(); ++i) {
                add(parts[i][1], parts[i][2]);
                add(parts[i][0], parts[i][1]);
                
                for (int j = 0; j < 3; ++j) {
                    if (get<0>(parts[i][j]) != 0 || get<1>(parts[i][j]) != 0
                        || get<2>(parts[i][j]) != 0) {
                        m[parts[i][0]].push_back(i);
                        break;
                    }
                }
                
            }
            for (const auto& p : m) { //handle collisions
                if (p.second.size() > 1U) {
                    for (int i : p.second) {
                        for (int j = 0; j < 3; ++j) {
                            get<0>(parts[i][j]) = 0;
                            get<1>(parts[i][j]) = 0;
                            get<2>(parts[i][j]) = 0;
                        }
                    }
                }
            }
        }
        long long mn = 1'000'000'000'000'000'000LL;
        int ind = -1, res = 0;
        for (int i = 0; i < (int)parts.size(); ++i) {
            long long dist = abs(get<0>(parts[i][0]))
                             + abs(get<1>(parts[i][0]))
                             + abs(get<2>(parts[i][0]));
            if (dist != 0)
                ++res;
            if (dist < mn && dist > 0) {
                mn = dist;
                ind = i;
            }
        }
        cout << res << endl; //part 2
        cout << ind << endl; //part 1
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    aoc20_1 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
