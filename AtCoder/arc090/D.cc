/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>
#include <sstream>

using namespace std;

class arc090_d {
private:
    bool dfs(const int u, const vector<vector<pair<int, int>>>& g, vector<int>& x) {
        for (const auto &p : g[u]) {
            int v = p.first, d = p.second;
            if (x[v] == -1) {
                x[v] = x[u] + d;
                if (!dfs(v, g, x)) {
                    return false;
                }
            } else if (x[v] != x[u] + d) {
                return false;
            }
        }
        return true;
    }
public:
    void solve(istream& in, ostream& out) {
        int N, M;
        in >> N >> M;
        vector<tuple<int, int, int>> lrd(M);
        vector<int> L(M), R(M), D(M);
        vector<vector<pair<int, int>>> g(N);
        for (int i = 0; i < M; ++i) {
            in >> L[i] >> R[i] >> D[i];
            lrd[i] = make_tuple(L[i], R[i], D[i]);
            g[L[i] - 1].emplace_back(R[i] - 1, D[i]);
            g[R[i] - 1].emplace_back(L[i] - 1, -D[i]);
        }
        vector<int> x(N, -1);
        constexpr int MID = 100'000'000;
        for (int u = 0; u < N; ++u) {
            if (x[u] == -1) {
                x[u] = MID;
                if (!dfs(u, g, x)) {
                    out << "No\n";
                    return;
                }
            }
        }
        out << "Yes\n";
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);
    arc090_d solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
