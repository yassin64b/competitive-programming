/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>
#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>
#include <sstream>

using namespace std;

struct edge {
    int u, v, d;
};

class arc090_e {
private:
    static constexpr int MOD = 1'000'000'007;
    void dijkstra(int s, const vector<vector<pair<int, int>>> &g,
                  vector<long long> &d, vector<int> &dp)
    {
        priority_queue<pair<long long, int>> pq;
        pq.emplace(-0, s);
        d[s] = 0;
        dp[s] = 1;
        while (!pq.empty()) {
            long long cur_d = -pq.top().first;
            int u = pq.top().second;
            pq.pop();
            if (cur_d > d[u]) {
                continue;
            }
            for (const pair<int, int> &p : g[u]) {
                int v = p.first, dist = p.second;
                if (d[v] == -1 || d[v] > cur_d + dist) {
                    d[v] = cur_d + dist;
                    dp[v] = dp[u];
                    pq.emplace(-d[v], v);
                } else if (d[v] == cur_d + dist) {
                    dp[v] += dp[u];
                    dp[v] %= MOD;
                }
            }
        }
    }
public:
    void solve(istream& in, ostream& out) {
        int N, M, S, T;
        in >> N >> M >> S >> T;
        --S;
        --T;
        vector<edge> edges(M);
        vector<vector<pair<int, int>>> g(N);
        for (int i = 0; i < M; ++i) {
            in >> edges[i].u >> edges[i].v >> edges[i].d;
            g[edges[i].u - 1].emplace_back(edges[i].v - 1, edges[i].d);
            g[edges[i].v - 1].emplace_back(edges[i].u - 1, edges[i].d);
        }
        vector<long long> d1(N, -1), d2(N, -1);
        vector<int> dp1(N, 0), dp2(N, 0);
        dijkstra(S, g, d1, dp1);
        dijkstra(T, g, d2, dp2);
        int total_path = 1LL * dp1[T] * dp1[T] % MOD;
        int meet_vert = 0, meet_edge = 0;
        for (int u = 0; u < N; ++u) {
            if (d1[u] == d1[T] / 2 && d1[T] % 2 == 0 && d1[u] == d2[u]) {
                meet_vert += 1LL * dp1[u] * dp1[u] % MOD * dp2[u] % MOD * dp2[u] % MOD;
                meet_vert %= MOD;
            }
        }
        for (int u = 0; u < N; ++u) {
            for (const auto &p : g[u]) {
                int v = p.first, c = p.second;
                if (d1[u] < (d1[T] + 1) / 2 && d2[v] < (d1[T] + 1) / 2
                    && d1[u] + d2[v] + c == d1[T])
                {
                    meet_edge += 1LL * dp1[u] * dp1[u] % MOD * dp2[v] % MOD * dp2[v] % MOD;
                    meet_edge %= MOD;
                }
            }
        }
        out << ((total_path - meet_vert + MOD) % MOD - meet_edge + MOD) % MOD << "\n";
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);
    arc090_e solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
