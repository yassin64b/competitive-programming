/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>

using namespace std;

int dirx[] = {1, -1, 0, 0};
int diry[] = {0, 0, 1, -1};

class agcC {
private:
    int H, W, K;
    bool isvalid(int x, int y) {
        return (x >= 0 && x < H && y >= 0 && y < W);
    }
public:
    void solve(istream& in, ostream& out) {
        in >> H >> W >> K;
        vector<vector<int>> A(H, vector<int>(W));
        int sx = -1, sy = -1;
        for (int i = 0; i < H; ++i) {
            for (int j = 0; j < W; ++j) {
                char c;
                in >> c;
                A[i][j] = (c == '#' ? 1 : 0);
                if (c == 'S') {
                    sx = i;
                    sy = j;
                }
            }
        }
        assert(sx != -1 && sy != -1);
        
        queue<tuple<int, int, int>> q, tq;
        vector<vector<int>> vis(H, vector<int>(W, 0));
        tq.emplace(sx, sy, K);
        while (!tq.empty()) {
            int cx, cy, ck;
            tie(cx, cy, ck) = tq.front();
            tq.pop();
            q.emplace(cx, cy, 1);
            if (cx == 0 || cx == H-1 || cy == 0 || cy == W-1) {
                out << "1\n";
                return;
            }
            vis[cx][cy] = 1;
            if (ck > 0) {
                for (int i = 0; i < 4; ++i) {
                    int xx = cx + dirx[i], yy = cy + diry[i];
                    if (isvalid(xx, yy) && !A[xx][yy] && !vis[xx][yy]) {
                        tq.emplace(xx, yy, ck-1);
                        vis[xx][yy] = 1;
                    }
                }
            }
            
        }
        
        int res = 1000 * 1000 * 1000;
        while (!q.empty()) {
            int cx, cy, cc;
            tie(cx, cy, cc) = q.front();
            q.pop();
            
            int dist1 = (H-1 - cx) / K + ((H-1 - cx) % K > 0 ? 1 : 0);
            int dist2 = (cx) / K + ((cx) % K > 0 ? 1 : 0);
            int dist3 = (W-1 - cy) / K + ((W-1 - cy) % K > 0 ? 1 : 0);
            int dist4 = (cy) / K + ((cy) % K > 0 ? 1 : 0);
            res = min(res, min(dist1 + 1, min(dist2 + 1, min(dist3 + 1, dist4 + 1))));
        }
        out << res << "\n";
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    agcC solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
