/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <cassert>

using namespace std;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pair<int,int>> vii;

class FenwickTree {
private:
    vector<int64_t> ft;
public:
    FenwickTree(int64_t n) {
        ft.assign(n + 1, 0);
    }
    int64_t rsq(int64_t b) {
        int sum = 0;
        for (; b; b -= (b & (-b))) {
            sum += ft[b];
        }
        return sum;
    }
    int64_t rsq(int64_t a, int64_t b) {
        if (a > b) return 0;
        return rsq(b) - rsq(a - 1);
    }
    void update(int64_t a, int64_t v) {
        for ( ; a < (int)ft.size(); a += (a & (-a))) {
            ft[a] += v;
        }
    }
    //NOTE: when using range update, rsq(x) is point query, unlike normally
    void update(int64_t a, int64_t b, int64_t v) {
        update(a, v);
        update(b + 1, -v);
    }
};

class arc068E {
public:
    void solve(istream& in, ostream& out) {
        int N, M;
        in >> N >> M;
        
        vector<pair<int,int>> souv(N);
        for (int i = 0; i < N; ++i) {
            in >> souv[i].first >> souv[i].second;
        }
        sort(souv.begin(), souv.end(), [](const pair<int,int> &lhs, const pair<int,int> &rhs) {
            return (lhs.second - lhs.first) > (rhs.second - rhs.first);
        });
        
        FenwickTree ft(M+10);
        for (int i = 0; i < N; ++i) {
            //out << souv[i].first << " " << souv[i].second << endl;
            ft.update(souv[i].first, souv[i].second, 1);
        }
        
        vector<int> ans(M);
        int j = 0;
        for (int i = M; i >= 1; --i) {
            //cout << "-> " << i << ": ";
            
            while (j < N && souv[j].second - souv[j].first + 1 > i) {
                //cout << "rem: " << souv[j].first << "," << souv[j].second << "; ";
                ft.update(souv[j].first, souv[j].second, -1);
                ++j;
            }
            
            int64_t k = i, res = 0;
            while (k <= M) {
                res += ft.rsq(k);
                k += i;
            }
            //cout << res << " + " << j << endl;
            ans[i-1] = res + j;
        }
        for (int i = 0; i < M; ++i) {
            out << ans[i] << endl;
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false);

    arc068E solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
