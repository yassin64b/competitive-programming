/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>
#include <sstream>

using namespace std;

struct command {
    int type, sz, a, b;
    command(int type_, int sz_, int a_, int b_)
            : type(type_), sz(sz_), a(a_), b(b_) {
    }
};

class aoc16_1 {
public:
    void solve(istream& in, ostream& out) {
        string s;
        vector<command> commands;
        while (getline(in, s, ',')) {
            stringstream ss(s);
            char type;
            ss >> type;
            if (type == 's') {
                int X;
                ss >> X;
                commands.emplace_back(0, X, 0, 0);
            } else if (type == 'x') {
                int A, B;
                ss >> A >> type >> B;
                commands.emplace_back(1, 0, A, B);
            } else {
                assert(type == 'p');
                char A, B;
                ss >> A >> type >> B;
                commands.emplace_back(2, 0, A, B);
            }
        }
        constexpr int SZ = 16;
        string progs(SZ, ' ');
        for (int i = 0; i < SZ; ++i)
            progs[i] = i + 'a';
        set<string> seen{progs};
        vector<string> cycle{progs};
        for (int i = 0; i < 1'000'000'000; ++i) {
            for (const command &com : commands) {
                if (com.type == 0) {
                    progs = progs.substr(SZ - com.sz) + progs.substr(0, SZ - com.sz);
                } else if (com.type == 1) {
                    swap(progs[com.a], progs[com.b]);
                } else {
                    swap(progs[progs.find(com.a)], progs[progs.find(com.b)]);
                }
            }
            if (seen.find(progs) != seen.end()) {
                cout << i+1 << endl;
                cout << cycle[1'000'000'000 % (i + 1)] << endl;
                break;
            }
            seen.insert(progs);
            cycle.push_back(progs);
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    aoc16_1 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
