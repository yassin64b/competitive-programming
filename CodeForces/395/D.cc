/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <cassert>

using namespace std;

typedef struct Rect {
    int x1, y1, x2, y2;
} Rect;

class TaskD {
private:
    inline bool overlap(const Rect &A, const Rect &B) {
        return (A.x1 <= B.x2 && A.x2 >= B.x1
                   && A.y1 < B.y2 && A.y2 > B.y1)
                || (A.x1 < B.x2 && A.x2 > B.x1
                    && A.y1 <= B.y2 && A.y2 >= B.y1);
    }
    
    bool dfs(int u, const vector<vector<int>> &g, vector<int> &color) {
        int col = 1;
        for (int i = 0; i < (int)g[u].size(); ++i) {
            int v = g[u][i];
            if (color[v] == col) {
                ++col;
            }
        }
        if (col == 5) {
            return false;
        }
        color[u] = col;
    
        for (int i = 0; i < (int)g[u].size(); ++i) {
            int v = g[u][i];
            if (color[v] == 0) {
                if (!dfs(v, g, color)) {
                    return false;
                }
            }
        }
        return true;
    }
public:
    void solve(istream& in, ostream& out) {
        int n;
        in >> n;
        
        //map<int,vector<int>> top, bot, left, right;
        vector<Rect> rects(n);
        for (int i = 0; i < n; ++i) {
            in >> rects[i].x1 >> rects[i].y1 >> rects[i].x2 >> rects[i].y2;
            //top[rects[i].y2].push_back(i);
            //bot[rects[i].y1].push_back(i);
            //left[rects[i].x1].push_back(i);
            //right[rects[i].x2].push_back(i);
        }
        
        /* WA, greedy doesn't work (and graph construction TLE)

        vector<vector<int>> g(n);
        for (int i = 0; i < n; ++i) {
            if (top.find(rects[i].y1) != top.end()) {
                const vector<int> &v = top[rects[i].y1];
                for (int j = 0; j < (int)v.size(); ++j) {
                    if (i != v[j] && overlap(rects[i], rects[v[j]])) {
                        g[i].push_back(v[j]);
                        g[v[j]].push_back(i);
                        //cout << "add edge " << i << " " << v[j] << "\n";
                    }
                }
            }
            if (bot.find(rects[i].y2) != bot.end()) {
                const vector<int> &v = bot[rects[i].y2];
                for (int j = 0; j < (int)v.size(); ++j) {
                    if (i != v[j] && overlap(rects[i], rects[v[j]])) {
                        g[i].push_back(v[j]);
                        g[v[j]].push_back(i);
                        //cout << "add edge " << i << " " << v[j] << "\n";
                    }
                }
            }
            if (left.find(rects[i].x2) != left.end()) {
                const vector<int> &v = left[rects[i].x2];
                for (int j = 0; j < (int)v.size(); ++j) {
                    if (i != v[j] && overlap(rects[i], rects[v[j]])) {
                        g[i].push_back(v[j]);
                        g[v[j]].push_back(i);
                        //cout << "add edge " << i << " " << v[j] << "\n";
                    }
                }
            }
            if (right.find(rects[i].x1) != right.end()) {
                const vector<int> &v = right[rects[i].x1];
                for (int j = 0; j < (int)v.size(); ++j) {
                    if (i != v[j] && overlap(rects[i], rects[v[j]])) {
                        g[i].push_back(v[j]);
                        g[v[j]].push_back(i);
                        //cout << "add edge " << i << " " << v[j] << "\n";
                    }
                }
            }
        }*/
        
        /*vector<int> color(n, 0);
        for (int i = 0; i < n; ++i) {
            if (color[i] == 0) {
                if (!dfs(i, g, color)) {
                    out << "NO\n";
                    return;
                }
            }
        }
        
        out << "YES\n";
        for (int i = 0; i < n; ++i) {
            out << color[i] << "\n";
        }*/
        
        out << "YES\n";
        for (int i = 0; i < n; ++i) {
            if ((rects[i].x1 % 2 + 2) % 2 == 0 && (rects[i].y1 % 2 + 2) % 2 == 0) {
                out << "1\n";
            } else if ((rects[i].x1 % 2 + 2) % 2 == 1 && (rects[i].y1 % 2 + 2) % 2 == 0) {
                out << "2\n";
            } else if ((rects[i].x1 % 2 + 2) % 2 == 1 && (rects[i].y1 % 2 + 2) % 2 == 1) {
                out << "3\n";
            } else if ((rects[i].x1 % 2 + 2) % 2 == 0 && (rects[i].y1 % 2 + 2) % 2 == 1) {
                out << "4\n";
            }
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false);

    TaskD solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
