/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin64b
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <queue>

using namespace std;

class TaskD {
public:
    void solve(istream& in, ostream& out) {
        int k, n;
        in >> k >> n;
        
        map<string, vector<int>> m;
        vector<string> strings(k);
        for (int i = 0; i < k; ++i) {
            int a;
            in >> strings[i] >> a;
            m[strings[i]].push_back(a);
        }
        
        for (auto &p : m) {
            vector<int> v = p.second;
            sort(v.begin(), v.end());
            m[p.first] = v;
        }
        map<string, vector<int>> taken;
        
        int64_t res = 0;
        for (size_t i = 0; i < strings.size(); ++i) {
            if (m[strings[i]].size() > 0) {
                string cur = strings[i], rev = strings[i];
                reverse(rev.begin(), rev.end());
                int val = m[cur][m[cur].size() - 1];
                //m[cur].pop_back();
                
                if (m.find(rev) != m.end()) {
                    if (cur != rev && m[rev].size() > 0) {
                        if (val + m[rev][m[rev].size() - 1] > 0) {
                            res += m[rev][m[rev].size() - 1] + val;
                            //out << "take " << rev << " " << cur << endl;
    
                            taken[cur].push_back(val);
                            taken[rev].push_back(m[rev][m[rev].size() - 1]);
                            
                            m[rev].pop_back();
                            m[cur].pop_back();
                        }
                    } else if (cur == rev && m[rev].size() > 1) {
                        if (val + m[rev][m[rev].size() - 2] > 0) {
                            res += m[rev][m[rev].size() - 2] + val;
                            //out << "take " << rev << " " << cur << endl;
    
                            taken[cur].push_back(val);
                            taken[rev].push_back(m[rev][m[rev].size() - 2]);
                            
                            m[rev].pop_back();
                            m[cur].pop_back();
                        }
                    }
                }
            }
        }
        //out << res << endl;
        for (auto &p : taken) {
            vector<int> v = p.second;
            sort(v.begin(), v.end());
            taken[p.first] = v;
        }
        
        int mn = 1e6, ind = -1;
        for (size_t i = 0; i < strings.size(); ++i) {
            if (taken.find(strings[i]) != taken.end() && taken[strings[i]].size() > 0) {
                string cur = strings[i], rev = strings[i];
                reverse(rev.begin(), rev.end());
                int val = taken[cur][0];
                if (val < 0 && cur == rev) {
                    //out << "take maybe: " << rev << " " << val << endl;
                    if (val < mn) {
                        mn = val;
                        ind = i;
                    }
                    //m[cur].pop_back();
                    
                }
            }
        }
        int mx = 0, ind2 = -1;
        for (size_t i = 0; i < strings.size(); ++i) {
            if (m[strings[i]].size() > 0) {
                string cur = strings[i], rev = strings[i];
                reverse(rev.begin(), rev.end());
                int val = m[cur][m[cur].size() - 1];
                //m[cur].pop_back();
                if (cur == rev) {
                    if (val > mx) {
                        ind2 = i;
                        mx = val;
                    }
                }
            }
        }
        if (ind != -1 && ind2 == -1) {
            //out << "take:0: " << strings[ind] << endl;
            //m[strings[ind]].pop_back();
            res -= mn;
        } else if (ind == -1 && ind2 != -1) {
            //out << "take:1: " << strings[ind2] << endl;
            res += mx;
        } else if (ind != -1 && ind2 != -1 && -mn > mx) {
            //out << "take:2: " << strings[ind] << " " << mn << endl;
    
            res -= mn;
        } else {
            //out << "take:3: " << mx << endl;
    
            res += mx;
        }
        
        out << res << endl;
    }
};


int main() {
    std::ios::sync_with_stdio(false);

    TaskD solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
