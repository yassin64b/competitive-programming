/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>

using namespace std;

struct node {
    int v, l, r;
};

constexpr int INF = 1000 * 1000 * 1000 + 10;

class TaskD {
private:
    void dfs(int u, const vector<node>& bst, int a, int b, set<int>& res) {
        if (u == -1) {
            return;
        }
        
        if (bst[u].v < a && bst[u].v > b) {
            res.insert(bst[u].v);
        }
        dfs(bst[u].l, bst, min(a, bst[u].v), b, res);
        dfs(bst[u].r, bst, a, max(b, bst[u].v), res);
    }
public:
    void solve(istream& in, ostream& out) {
        int n;
        in >> n;
        vector<node> bst(n);
        vector<int> isRoot(n, 1);
        for (int i = 0; i < n; ++i) {
            in >> bst[i].v >> bst[i].l >> bst[i].r;
            if (bst[i].l != -1) {
                --bst[i].l;
                isRoot[bst[i].l] = 0;
            }
            if (bst[i].r != -1) {
                --bst[i].r;
                isRoot[bst[i].r] = 0;
            }
        }
        int root = -1;
        for (int i = 0; i < n; ++i) {
            if (isRoot[i]) {
                assert(root == -1);
                root = i;
            }
        }
        assert(root != -1);
        
        set<int> res;
        dfs(root, bst, INF, -INF, res);
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += res.count(bst[i].v);
        }
        out << n-ans << "\n";
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    TaskD solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
