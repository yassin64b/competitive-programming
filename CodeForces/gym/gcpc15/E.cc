/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>

using namespace std;

class gcpc15_E {
public:
    void solve(istream& in, ostream& out) {
        int N, M, K;
        in >> N >> M >> K;
        vector<vector<pair<int, int>>> g(N);
        vector<int> route(K);
        for (int i = 0; i < K; ++i) {
            in >> route[i];
            --route[i];
        }
        for (int i = 0; i < M; ++i) {
            int a, b, c;
            in >> a >> b >> c;
            g[a-1].emplace_back(b-1, c);
            g[b-1].emplace_back(a-1, c);
        }
    
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq; //first = dist, second = node
        pq.emplace(0, 0);
        vector<pair<int, bool>> dist_cnt(N, {1000*1000*1000, 0}); //first = best distance, second == true iff reachable in multiple ways
        dist_cnt[0] = {0, false};
        
        while (!pq.empty()) {
            int dist = pq.top().first, u = pq.top().second;
            int best_dist = dist_cnt[u].first;
            bool cur_cnt = dist_cnt[u].second;
            pq.pop();
    
            if (dist > best_dist) {
                continue;
            }
            assert(dist == best_dist);
            
            if (u == N-1) {
                if (cur_cnt) {
                    out << "yes\n";
                } else {
                    out << "no\n";
                }
                return;
            }
    
            for (const pair<int, int> &p : g[u]) {
                int nxt_dist = p.second + dist, v = p.first;
                if (nxt_dist < dist_cnt[v].first) {
                    pq.emplace(nxt_dist, v);
                    dist_cnt[v].first = nxt_dist;
                    dist_cnt[v].second = cur_cnt;
                } else if (nxt_dist == dist_cnt[v].first) {
                    dist_cnt[v].second = true;
                }
            }
        }
        assert(true);
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    gcpc15_E solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
