/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>

using namespace std;

constexpr int dx[4]{1, -1, 0, 0};
constexpr int dy[4]{0, 0, 1, -1};
constexpr int INF = -1000*1000*1000;

class C374 {
private:
    char nxt(char c) {
        if (c == 'D') {
            return 'I';
        } else if (c == 'I') {
            return 'M';
        } else if (c == 'M') {
            return 'A';
        } else if (c == 'A') {
            return 'D';
        }
        assert(true);
        return 0;
    }
    int n, m;
    bool dfs(int a, int b, const vector<string>& g, vector<vector<int>>& vis, vector<vector<int>>& st, vector<pair<int, int>>& topo) {
        vis[a][b] = 1;
        st[a][b] = 1;
        for (int i = 0; i < 4; ++i) {
            if (a+dx[i] >= 0 && a+dx[i] < n && b+dy[i] >= 0 && b+dy[i] < m && g[a+dx[i]][b+dy[i]] == nxt(g[a][b])) {
                if (!vis[a+dx[i]][b+dy[i]]) {
                    if (!dfs(a+dx[i], b+dy[i], g, vis, st, topo)) {
                        return false;
                    }
                } else if (st[a+dx[i]][b+dy[i]]) {
                    return false;
                }
                
            }
        }
        st[a][b] = 0;
        topo.emplace_back(a, b);
        return true;
    }
public:
    void solve(istream& in, ostream& out) {
        in >> n >> m;
        vector<string> grid(n);
        for (int i = 0; i < n; ++i) {
            in >> grid[i];
        }
        
        vector<vector<int>> vis(n, vector<int>(m, 0)), st(n, vector<int>(m, 0));
        vector<pair<int, int>> topo;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 'D' && !vis[i][j]) {
                    if (!dfs(i, j, grid, vis, st, topo)) {
                        out << "Poor Inna!\n";
                        return;
                    }
                }
            }
        }
        
        vector<vector<int>> dist(n, vector<int>(m, INF));
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 'D') {
                    dist[i][j] = 1;
                }
            }
        }
        reverse(topo.begin(), topo.end());
        for (const pair<int, int>& p : topo) {
            int a = p.first, b = p.second;
            if (dist[a][b] != INF) {
                for (int i = 0; i < 4; ++i) {
                    if (a+dx[i] >= 0 && a+dx[i] < n && b+dy[i] >= 0 && b+dy[i] < m && grid[a+dx[i]][b+dy[i]] == nxt(grid[a][b])) {
                        dist[a+dx[i]][b+dy[i]] = max(dist[a+dx[i]][b+dy[i]], dist[a][b] + 1);
                    }
                }
            }
        }
        
        int mx = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (dist[i][j] != INF && grid[i][j] == 'A') {
                    mx = max(mx, dist[i][j]/4);
                }
            }
        }
        if (mx == 0) {
            out << "Poor Dima!\n";
        } else {
            out << mx << "\n";
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    C374 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
