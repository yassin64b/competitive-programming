/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>

using namespace std;

void process(int N, vector<int> &T, vector<vector<int>> &P) {
    int i, j;
    
    //we initialize every element in P with -1
    for (i = 0; i < N; i++)
        for (j = 0; (1 << j) < N; j++)
            P[i][j] = -1;
    
    //the first ancestor of every node i is T[i]
    for (i = 0; i < N; i++)
        P[i][0] = T[i];
    
    //bottom up dynamic programing
    for (j = 1; (1 << j) < N; j++)
        for (i = 0; i < N; i++)
            if (P[i][j - 1] != -1)
                P[i][j] = P[P[i][j - 1]][j - 1];
}

int query(vector<vector<int>> &P, vector<int> &T,
          vector<int> &L, int p, int q) {
    int tmp, log, i;
    
    //if p is situated on a higher level than q then we swap them
    if (L[p] < L[q])
        tmp = p, p = q, q = tmp;
    
    //we compute the value of [log(L[p)]
    for (log = 1; (1 << log) <= L[p]; log++);
    log--;
    
    //we find the ancestor of node p situated on the same level
    //with q using the values in P
    for (i = log; i >= 0; i--)
        if (L[p] - (1 << i) >= L[q])
            p = P[p][i];
    
    if (p == q)
        return p;
    
    //we compute LCA(p, q) using the values in P
    for (i = log; i >= 0; i--)
        if (P[p][i] != -1 && P[p][i] != P[q][i])
            p = P[p][i], q = P[q][i];
    
    return T[p];
}

void dfs(int u, int level, const vector<vector<int>> &g, vector<int> &T, vector<int> &L, vector<int> &vis) {
    vis[u] = 1;
    L[u] = level;
    for (int v : g[u]) {
        if (!vis[v]) {
            T[v] = u;
            dfs(v, level+1, g, T, L, vis);
        }
    }
}

long long dfs(int u, const vector<int> &start, map<pair<int,int>,long long> &m, const vector<vector<int>> &g, vector<int> &vis) {
    vis[u] = 1;
    long long ret = start[u];
    for (int v : g[u]) {
        if (!vis[v]) {
            long long tmp = dfs(v, start, m, g, vis);
            ret += tmp;
            m[{u, v}] = tmp;
            m[{v, u}] = tmp;
        }
    }
    return ret;
}

class C191 {
public:
    void solve(istream& in, ostream& out) {
        int n;
        in >> n;
        vector<vector<int>> g(n);
        vector<pair<int,int>> edges(n-1);
        for (int i = 0; i < n-1; ++i) {
            int u, v;
            in >> u >> v;
            g[u-1].push_back(v-1);
            g[v-1].push_back(u-1);
            edges[i] = {u-1, v-1};
        }
        vector<int> start(n, 0), T(n), vis(n, 0), L(n, 0);
        T[0] = -1;
        dfs(0, 0, g, T, L, vis);
        vector<vector<int>> P(n, vector<int>(log2(n)+2));
        process(n, T, P);
        
        int k;
        in >> k;
        for (int i = 0; i < k; ++i) {
            int a, b;
            in >> a >> b;
            --a; --b;
            int lca = query(P, T, L, a, b);
            ++start[a]; ++start[b];
            start[lca] -= 2;
        }
    
        map<pair<int,int>,long long> m;
        vis.assign(n, 0);
        dfs(0, start, m, g, vis);
        for (int i = 0; i < n-1; ++i) {
            out << m[edges[i]] << " ";
        }
        out << "\n";
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    C191 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
