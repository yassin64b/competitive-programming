/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <numeric>
#include <cassert>
#include <unordered_set>

using namespace std;

class C514 {
public:
    void solve(istream& in, ostream& out) {
        int n, m;
        in >> n >> m;
        string s;
        map<int, unordered_set<string>> sets;
        constexpr int a = 41;
        vector<int> pows(1000 * 1000);
        pows[0] = 1;
        for (int i = 1; i < 1000 * 1000; ++i) {
            pows[i] = pows[i - 1] * a;
        }
        for (int i = 0; i < n; ++i) {
            in >> s;
            int hash = 0;
            for (int j = 0; j < (int)s.size(); ++j) {
                hash += pows[j + 1] * s[j];
            }
            sets[hash].insert(s);
        }
        for (int i = 0; i < m; ++i) {
            in >> s;
            bool found = false;
            int hash = 0;
            for (int j = 0; j < (int)s.size(); ++j) {
                hash += pows[j + 1] * s[j];
            }
            for (int j = 0; !found && j < (int)s.size(); ++j) {
                const char c = s[j];
                if (s[j] != 'a') {
                    hash -= pows[j + 1] * s[j];
                    s[j] = 'a';
                    hash += pows[j + 1] * s[j];
                    if (sets.find(hash) != sets.end()) {
                        if (sets[hash].find(s) != sets[hash].end()) { //to prevent false positive
                            found = true;
                        }
                    }
                    hash -= pows[j + 1] * s[j];
                    s[j] = c;
                    hash += pows[j + 1] * s[j];
                }
                if (s[j] != 'b') {
                    hash -= pows[j + 1] * s[j];
                    s[j] = 'b';
                    hash += pows[j + 1] * s[j];
                    if (sets.find(hash) != sets.end()) {
                        if (sets[hash].find(s) != sets[hash].end()) {
                            found = true;
                        }
                    }
                    hash -= pows[j + 1] * s[j];
                    s[j] = c;
                    hash += pows[j + 1] * s[j];
                }
                if (s[j] != 'c') {
                    hash -= pows[j + 1] * s[j];
                    s[j] = 'c';
                    hash += pows[j + 1] * s[j];
                    if (sets.find(hash) != sets.end()) {
                        if (sets[hash].find(s) != sets[hash].end()) {
                            found = true;
                        }
                    }
                    hash -= pows[j + 1] * s[j];
                    s[j] = c;
                    hash += pows[j + 1] * s[j];
                }
            }
            if (!found) {
                out << "NO\n";
            } else {
                out << "YES\n";
            }
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false); cin.tie(nullptr);

    C514 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
