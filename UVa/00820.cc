/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author yassin
 */

#include <fstream>

#include <iostream>
#include <vector>
#include <string>
#include <utility>
#include <algorithm>
#include <map>
#include <set>
#include <cmath>
#include <cstdlib>
#include <tuple>
#include <queue>
#include <functional>
#include <stack>
#include <cassert>

using namespace std;

typedef vector<int> vi;
typedef vector<vi> vvi;
typedef vector<pair<int,int>> vii;

class uva820 {
private:
    vector<int> bfs(int s, int t, const vector<vector<int>> &g) {
        vector<int> par(g.size(), -1);
        
        vector<int> path;
        queue<int> q;
        q.push(s);
        par[s] = -2;
    
        bool finished = false;
        while (!q.empty() && !finished) {
            int u = q.front();
            q.pop();
        
            for (int v = 0; !finished && v < (int)g[u].size(); ++v) {
                if (g[u][v] > 0 && par[v] == -1) {
                    par[v] = u;
                    
                    if (v == t) {
                        finished = true;
                    } else {
                        q.push(v);
                    }
                }
            }
        }
        
        int cur = t;
        while (cur >= 0) {
            path.push_back(cur);
            cur = par[cur];
        }
        reverse(path.begin(), path.end());
        
        return move(path);
    }
    
    int maxflow(int s, int t, vector<vector<int>> &g) {
        int cap = 0;
        
        while (true) {
            //1 find augmenting path, terminate if none
            vector<int> path = bfs(s, t, g);
            if (path.size() <= 1) {
                return cap;
            }
    
            //2 augment along path with max capacity
            int mxcap = 1e9;
            for (int i = 0; i < (int) path.size() - 1; ++i) {
                mxcap = min(mxcap, g[path[i]][path[i+1]]);
            }
            for (int i = 0; i < (int) path.size() - 1; ++i) {
                g[path[i]][path[i+1]] -= mxcap;
                g[path[i+1]][path[i]] += mxcap;
            }
            cap += mxcap;
            
            /*cout << endl;
            for (int i = 0; i < (int)path.size(); ++i) {
                cout << path[i] + 1 << " ";
            }
            cout << mxcap << endl;
            cin.get();*/
        }
    }
    
public:
    void solve(istream& in, ostream& out) {
        int n, num = 0;
        while (in >> n && n && ++num) {
            int s, t, c;
            in >> s >> t >> c;
            
            vector<vector<int>> g(n, vector<int>(n, 0));
            for (int i = 0; i < c; ++i) {
                int u, v, b;
                in >> u >> v >> b;
                g[u-1][v-1] += b;
                g[v-1][u-1] += b;
            }
            
            out << "Network " << num << "\n";
            out << "The bandwidth is " << maxflow(s-1, t-1, g) << ".\n\n";
        }
    }
};


int main() {
    std::ios::sync_with_stdio(false);

    uva820 solver;
    std::istream& in(std::cin);
    std::ostream& out(std::cout);
    solver.solve(in, out);
    return 0;
}
